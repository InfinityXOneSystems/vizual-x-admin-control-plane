/**
 * VIZUAL-X ADMIN CONTROL PLANE - SYNC SERVICE
 * 
 * Purpose: Heartbeat monitor for external systems (GitHub API, Google Cloud API)
 *          Provides sync status to the Admin Control Plane UI
 */

import * as fs from 'fs';
import * as path from 'path';

export interface SyncStatusDetail {
    Status: string;
    Details: string[];
}

export interface SyncStatus {
    GitSync: SyncStatusDetail;
    DockerSync: SyncStatusDetail;
    GCPSync: SyncStatusDetail;
    CloudflareCheck: SyncStatusDetail;
    AuthCheck: SyncStatusDetail;
}

export interface SyncReport {
    timestamp: string;
    status: SyncStatus;
    dryRun: boolean;
}

export interface HeartbeatStatus {
    service: string;
    status: 'healthy' | 'degraded' | 'down' | 'unknown';
    lastCheck: string;
    responseTime?: number;
    error?: string;
}

class SyncService {
    private syncStatusPath: string;
    private heartbeatCache: Map<string, HeartbeatStatus>;
    private cacheTimeout: number = 60000; // 1 minute cache

    constructor() {
        // Path to the sync status file created by infinity-sync.ps1
        this.syncStatusPath = path.join(__dirname, '../../..', 'readiness', 'infinity-sync-status.json');
        this.heartbeatCache = new Map();
    }

    /**
     * Read the latest sync status from the file generated by infinity-sync.ps1
     */
    public async getSyncStatus(): Promise<SyncReport | null> {
        try {
            if (!fs.existsSync(this.syncStatusPath)) {
                return null;
            }

            const fileContent = fs.readFileSync(this.syncStatusPath, 'utf-8');
            const syncReport: SyncReport = JSON.parse(fileContent);
            
            return syncReport;
        } catch (error) {
            console.error('[SyncService] Failed to read sync status:', error);
            return null;
        }
    }

    /**
     * Check if the sync status is fresh (updated within last 5 minutes)
     */
    public async isSyncStatusFresh(): Promise<boolean> {
        const syncStatus = await this.getSyncStatus();
        if (!syncStatus) return false;

        const lastUpdate = new Date(syncStatus.timestamp);
        const now = new Date();
        const diffMinutes = (now.getTime() - lastUpdate.getTime()) / 1000 / 60;

        return diffMinutes < 5;
    }

    /**
     * Heartbeat check for GitHub API
     */
    public async checkGitHubHeartbeat(): Promise<HeartbeatStatus> {
        const cacheKey = 'github';
        const cached = this.getCachedHeartbeat(cacheKey);
        if (cached) return cached;

        const heartbeat: HeartbeatStatus = {
            service: 'GitHub API',
            status: 'unknown',
            lastCheck: new Date().toISOString()
        };

        try {
            const startTime = Date.now();
            const response = await fetch('https://api.github.com/zen', {
                method: 'GET',
                headers: {
                    'User-Agent': 'Vizual-X-Admin-Control-Plane'
                }
            });
            const responseTime = Date.now() - startTime;

            if (response.ok) {
                heartbeat.status = responseTime < 500 ? 'healthy' : 'degraded';
                heartbeat.responseTime = responseTime;
            } else {
                heartbeat.status = 'down';
                heartbeat.error = `HTTP ${response.status}`;
            }
        } catch (error) {
            heartbeat.status = 'down';
            heartbeat.error = error instanceof Error ? error.message : 'Unknown error';
        }

        this.cacheHeartbeat(cacheKey, heartbeat);
        return heartbeat;
    }

    /**
     * Heartbeat check for Google Cloud API
     */
    public async checkGoogleCloudHeartbeat(): Promise<HeartbeatStatus> {
        const cacheKey = 'gcp';
        const cached = this.getCachedHeartbeat(cacheKey);
        if (cached) return cached;

        const heartbeat: HeartbeatStatus = {
            service: 'Google Cloud API',
            status: 'unknown',
            lastCheck: new Date().toISOString()
        };

        try {
            const startTime = Date.now();
            // Check Google Cloud status page (public endpoint)
            const response = await fetch('https://status.cloud.google.com/', {
                method: 'HEAD',
                headers: {
                    'User-Agent': 'Vizual-X-Admin-Control-Plane'
                }
            });
            const responseTime = Date.now() - startTime;

            if (response.ok) {
                heartbeat.status = responseTime < 1000 ? 'healthy' : 'degraded';
                heartbeat.responseTime = responseTime;
            } else {
                heartbeat.status = 'down';
                heartbeat.error = `HTTP ${response.status}`;
            }
        } catch (error) {
            heartbeat.status = 'down';
            heartbeat.error = error instanceof Error ? error.message : 'Unknown error';
        }

        this.cacheHeartbeat(cacheKey, heartbeat);
        return heartbeat;
    }

    /**
     * Heartbeat check for Cloudflare
     */
    public async checkCloudflareHeartbeat(): Promise<HeartbeatStatus> {
        const cacheKey = 'cloudflare';
        const cached = this.getCachedHeartbeat(cacheKey);
        if (cached) return cached;

        const heartbeat: HeartbeatStatus = {
            service: 'Cloudflare (vizual-x.com)',
            status: 'unknown',
            lastCheck: new Date().toISOString()
        };

        try {
            const startTime = Date.now();
            const response = await fetch('https://vizual-x.com', {
                method: 'HEAD',
                headers: {
                    'User-Agent': 'Vizual-X-Admin-Control-Plane'
                }
            });
            const responseTime = Date.now() - startTime;

            if (response.ok) {
                heartbeat.status = responseTime < 1000 ? 'healthy' : 'degraded';
                heartbeat.responseTime = responseTime;
            } else {
                heartbeat.status = 'down';
                heartbeat.error = `HTTP ${response.status}`;
            }
        } catch (error) {
            heartbeat.status = 'down';
            heartbeat.error = error instanceof Error ? error.message : 'Unknown error';
        }

        this.cacheHeartbeat(cacheKey, heartbeat);
        return heartbeat;
    }

    /**
     * Get all heartbeats in one call
     */
    public async getAllHeartbeats(): Promise<HeartbeatStatus[]> {
        const [github, gcp, cloudflare] = await Promise.all([
            this.checkGitHubHeartbeat(),
            this.checkGoogleCloudHeartbeat(),
            this.checkCloudflareHeartbeat()
        ]);

        return [github, gcp, cloudflare];
    }

    /**
     * Get comprehensive sync overview
     */
    public async getSyncOverview(): Promise<{
        syncStatus: SyncReport | null;
        syncStatusFresh: boolean;
        heartbeats: HeartbeatStatus[];
        timestamp: string;
    }> {
        const syncStatus = await this.getSyncStatus();
        const syncStatusFresh = await this.isSyncStatusFresh();
        const heartbeats = await this.getAllHeartbeats();

        return {
            syncStatus,
            syncStatusFresh,
            heartbeats,
            timestamp: new Date().toISOString()
        };
    }

    /**
     * Cache heartbeat results to avoid hammering external APIs
     */
    private cacheHeartbeat(key: string, heartbeat: HeartbeatStatus): void {
        this.heartbeatCache.set(key, heartbeat);
        
        // Auto-expire cache after timeout
        setTimeout(() => {
            this.heartbeatCache.delete(key);
        }, this.cacheTimeout);
    }

    /**
     * Get cached heartbeat if still valid
     */
    private getCachedHeartbeat(key: string): HeartbeatStatus | null {
        return this.heartbeatCache.get(key) || null;
    }
}

// Export singleton instance
export const syncService = new SyncService();
